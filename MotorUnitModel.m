function [output] = MotorUnitModel(t,U,modelParameter,Fs)

N_MU = modelParameter.N; %number of motor unit
i_MU = 1:N_MU; %motor unit identification index
RR_MU = modelParameter.RR; %range of recruitment in unit of fold
a_MU = log(RR_MU)/N_MU; %coefficient to establish a range of threshold values
RTE_MU = exp(a_MU*i_MU); %recruitment threshold excitation
MFR_MU = modelParameter.MFR; %minimum firing rate constant for all motoneurons
g_e_MU = modelParameter.g_e; %missing parameter from the paper
PFR1_MU = modelParameter.PFR1; %the peak firing rate of the first recruited motoneuron in unit of impulse/sec
PFRD_MU = modelParameter.PFRD; %the desired difference in peak firing rates between the first and last units in unit of impulse/sec
RTEn_MU = exp(a_MU*N_MU); %recruitment threshold of the last motor unit
PFR_MU = PFR1_MU - PFRD_MU * (RTE_MU./RTEn_MU); %peak firing rate
PFRn_MU = PFR1_MU - PFRD_MU; %peak firing rate of the last motor unit
Emax_MU = RTEn_MU + (PFRn_MU - MFR_MU)/g_e_MU; %maximum excitatory input
cv_MU = modelParameter.cv; %ISI variability as per coefficient of variation (=mean/SD)

RP_MU = modelParameter.RP; %range of twich force across motor untis in unit of fold
b_MU = log(RP_MU)/N_MU; %coefficient to establish a range of twich force values
P_MU = exp(b_MU*i_MU); %force generated by a motor unit as a function of its recruitment threshold
T_L_MU = modelParameter.T_L; %the longest duration contraction time desired for the pool in unit of ms
RT_MU = modelParameter.RT; % range of contraction time in unit of fold
c_MU = log(100)/log(RT_MU); %coefficient to establish a range of contraction time values
T_MU = (T_L_MU.* (1./P_MU).^(1/c_MU))./1000; %contraction time
%P_amp = modelParameter.P_amp;
%P_MU = exp(b_MU*i_MU)*P_amp; %force generated by a motor unit as a function of its recruitment threshold
P_MU = exp(b_MU*i_MU);
t_twitch = 0:1/Fs:1;
twitch = zeros(N_MU,length(t_twitch));

for j = 1:N_MU
    twitch(j,:) =  P_MU(j).*t_twitch./T_MU(j).*exp(1-t_twitch./T_MU(j));
end

outputFR = zeros(N_MU,length(t));
outputG = zeros(N_MU,length(t));
spike_time = zeros(1,N_MU);
spike_train = zeros(N_MU,length(t));
force = zeros(N_MU,length(t));
outputIndex = cell(1,N_MU);
E = U*Emax_MU;

for i = 1:length(t)
    FR_MU = g_e_MU.*(E(i) - RTE_MU) + MFR_MU;
    outputFR(:,i) = FR_MU;
    
    index_temp = ~any(spike_train,2);
    index_1 = i_MU(FR_MU>=MFR_MU & index_temp');
    %index_temp_2 = i_MU(spike_time==i);
    index_2 = i_MU(FR_MU>=MFR_MU & spike_time==i);
    index = [index_1 index_2];
    outputIndex{i} = index;
    for j = 1:length(index)
        n = index(j);
        if FR_MU(n) > PFR_MU(n)
            FR_MU(n) = PFR_MU(n);
        end
        spike_train_temp = zeros(1,length(t));
        if ~any(spike_train(n,:)) % initial time
            spike_train(n,i) = 1;
            spike_train_temp(i) = 1;
            mu = 1/FR_MU(n);
            Z = randn(1);
            Z(Z>3.9) = 3.9;
            Z(Z<-3.9) = -3.9;
            spike_time_temp = (mu + mu*cv_MU*Z)*Fs;
            spike_time(n) = round(spike_time_temp) + i;
            
            StimulusRate = T_MU(n)*FR_MU(n);
            if StimulusRate > 0 && StimulusRate <= 0.4
                g = 1;
            elseif StimulusRate > 0.4
                S_MU = 1 - exp(-2*(StimulusRate)^3);
                g = (S_MU/StimulusRate)/0.3;
            end
            outputG(n,i) = g;
            force_temp = conv(spike_train_temp,g*twitch(n,:));             
            force(n,:) = force(n,:)+ force_temp(1:length(t));
        else
            if spike_time(n) == i
                spike_train(n,i) = 1;
                spike_train_temp(i) = 1;
                mu = 1/FR_MU(n);
                Z = randn(1);
                Z(Z>3.9) = 3.9;
                Z(Z<-3.9) = -3.9;
                spike_time_temp = (mu + mu*cv_MU*Z)*Fs;
                spike_time(n) = round(spike_time_temp) + i;
                
                StimulusRate = T_MU(n)*FR_MU(n);
                if StimulusRate > 0 && StimulusRate <= 0.4
                    g = 1;
                elseif StimulusRate > 0.4
                    S_MU = 1 - exp(-2*(StimulusRate)^3);
                    g = (S_MU/StimulusRate)/0.3;
                end
                outputG(n,i) = g;
                
                force_temp = conv(spike_train_temp,g*twitch(n,:));             
                force(n,:) = force(n,:)+ force_temp(1:length(t));
            elseif i > spike_time(n) + round(1/FR_MU(n)*Fs)
                spike_train(n,i) = 1;
                spike_train_temp(i) = 1;
                spike_time(n) = i;
                StimulusRate = T_MU(n)*FR_MU(n);
                if StimulusRate > 0 && StimulusRate <= 0.4
                    g = 1;
                elseif StimulusRate > 0.4
                    S_MU = 1 - exp(-2*(StimulusRate)^3);
                    g = (S_MU/StimulusRate)/0.3;
                end
                outputG(n,i) = g;
                
                force_temp = conv(spike_train_temp,g*twitch(n,:));             
                force(n,:) = force(n,:)+ force_temp(1:length(t));
%                 force_temp = twitch_function(twitch(n,:),force(n,i),T_MU(n),Fs);             
%                 force(n,i:i+length(force_temp)-1) = force_temp;
%             else
%                 break
            end
        end
        
    end
    
end

output.Force = force;
output.SpikeTrain = spike_train;
output.TotalForce = sum(force);
output.FR = outputFR;
output.g = outputG;
output.index = outputIndex;

end